# AWS オブザーバビリティ学習用 eコマースアプリ - 23週間自己学習ロードマップ（統合版）

## 1. はじめに

このロードマップは、AWSのオブザーバビリティパターン（ログ、メトリクス、トレース）を学ぶための自己学習ガイドです。Goバックエンド、Next.jsフロントエンド、AWS/LocalStackを使用して、eコマースアプリケーションを構築しながら、観測性の実装方法を段階的に学びます。

### 1.1. プロジェクト概要

このプロジェクトでは、オブザーバビリティの3本柱（ログ、メトリクス、トレース）をセットで学びながら、機能開発とオブザーバビリティ実装を並行して進めます。特にOpenTelemetryに重点を置き、AWS SDK v2との比較も行います。また、認証システムの実装と観測性についても深く学びます。

このロードマップの特徴：

- 週ごとの具体的な学習目標と実装タスク
- バックエンド、フロントエンド、オブザーバビリティの統合的な学習
- 独学でも進められる明確なチェックポイントと自己評価基準
- AWS SDK v2とOpenTelemetryの両方のアプローチによる比較学習
- LocalStackを活用した低コストでの学習環境

### 1.2. 学習目標の優先順位

1. **OpenTelemetryの習得**：AWS SDKからOpenTelemetryへの移行と、その利点の理解
2. **オブザーバビリティの3本柱を統合的に学習**：ログ、メトリクス、トレースをセットで実装し理解する
3. **サーバーレスオブザーバビリティの早期学習**：Lambdaを用いたサーバーレス機能と観測手法を早期に学ぶ
4. **認証システムの実装とオブザーバビリティ**：顧客認証と管理者認証の実装と、それぞれの観測特性を学ぶ
5. **高度なモニタリング手法の習得**：RUM、合成モニタリング、異常検出等の高度なテクニックを学ぶ
6. **機能開発とオブザーバビリティの統合**：各機能の実装と同時にオブザーバビリティも実装する
7. **本番環境デプロイと耐障害性の理解**：実際のAWS環境でのデプロイと障害テストを通じた学習

### 1.3. 技術スタック

#### 1.3.1. フロントエンド

- Next.js (Reactベースのフレームワーク)
- TypeScript
- TailwindCSS
- AWS S3 + CloudFront (静的アセットホスティング)

#### 1.3.2. バックエンド

- Go言語 (Echo Webフレームワーク)
- sqlboiler (MySQLに特化したORM)
- OpenAPI (oapi-codegen でのコード生成)
- slog (構造化ログ)
- AWS Fargate (ECS)
- AWS Lambda (サーバーレス機能)
- MySQL (RDS)
- AWS ALB (Application Load Balancer)

#### 1.3.3. 認証

- AWS Cognito または自前実装 (学習中に比較検討)
- JWT認証
- OAuthによるソーシャルログイン連携

#### 1.3.4. オブザーバビリティ

1. **AWS SDK v2アプローチ**
   - X-Ray SDK for Go v2
   - CloudWatch SDK v2
   - slog + CloudWatch Logs

2. **OpenTelemetryアプローチ** (優先的に学習)
   - OpenTelemetry Go SDK
   - AWS Distro for OpenTelemetry (ADOT)
   - X-Ray Exporter

## 2. 学習の進め方

### 2.1. 基本的なアプローチ

1. **週単位で進める**: 各週は約20時間の学習を想定しています。自分のペースに合わせて調整してください。
2. **実装と学習の繰り返し**: コードを書きながら概念を学ぶことで、知識が定着します。
3. **チェックポイントで進捗確認**: 各週の終わりに自己評価を行い、必要に応じて復習します。
4. **段階的な複雑さ**: 基本から始めて徐々に高度な概念へと進みます。
5. **LocalStackの活用**: AWSの実環境へのデプロイ前に、LocalStackでコスト効率よく学習できます。

### 2.2. 効果的な学習サイクル

自己学習を効果的に進めるためのサイクルは以下の通りです：

1. **全体ロードマップの確認** - 現在の位置と目標を把握
2. **フェーズガイドの理解** - 取り組むフェーズの全体像を把握
3. **週単位のハンズオン実施** - 詳細な手順に従って実装
4. **技術トピックの深堀り** - 必要に応じて関連技術の詳細を学習
5. **自己評価の実施** - 学習成果を評価し、理解を確認
6. **次のステップへ進む** - 次の週またはフェーズに進む

このサイクルを繰り返すことで、体系的に学習を進めることができます。

### 2.3. 注意点

- 個人のペースに合わせて進行を調整することが重要です
- 実際に手を動かしコードを書くことを優先しましょう
- 問題に直面したら、その都度深く理解するよう努めましょう
- 実装したコードを定期的にレビューし、改善点を見つけましょう
- AWS環境のコストに注意し、必要に応じてLocalStackを活用しましょう

## 3. 全体スケジュール概要

### 3.1. フェーズ1: 基盤構築と商品閲覧機能 (週1-5)

#### 3.1.1. 目標

- 開発環境の構築
- バックエンド/フロントエンドの基本構造実装
- データモデルと基本API
- サーバーレスアーキテクチャの基礎学習と基本実装
- 商品カタログ機能と顧客・管理者向けUI

#### 3.1.2. 技術的成果物

- 完全な開発環境（Docker Compose、Go/Echo、Next.js）
- 基本的なバックエンド構造（API、データアクセス層）
- 商品閲覧が可能なMVPアプリケーション
- 商品カタログデータモデルとAPI
- 管理画面の基礎
- 基本的なサーバーレス画像処理機能

#### 3.1.3. 習得するスキル

- Docker、Go、Next.jsの基本的な開発環境構築
- REST APIの設計と実装
- データベーススキーマ設計とORM活用
- Reactコンポーネントの設計と実装
- サーバーレスアーキテクチャの基本概念

### 3.2. フェーズ2: 統合オブザーバビリティとサーバーレス (週6-10)

#### 3.2.1. 目標

- オブザーバビリティの3本柱を統合的に実装
- 高度なサーバーレス機能の導入
- AWS SDK v2によるログ、メトリクス、トレースの実装
- イベント駆動型アーキテクチャの実装
- サーバーレス機能のオブザーバビリティ

#### 3.2.2. 技術的成果物

- 完全な統合オブザーバビリティシステム（ログ、メトリクス、トレース）
- 構造化ログシステム
- メトリクス収集パイプライン
- 分散トレースシステム
- 高度なサーバーレス機能
- ダッシュボードと可視化ツール
- 相関分析の基盤

#### 3.2.3. 習得するスキル

- AWS CloudWatchの詳細理解
- AWS X-Rayによるトレース実装
- 構造化ログ設計と実装
- メトリクス設計と収集
- Lambda関数の実装とモニタリング
- イベント駆動型設計の実践
- オブザーバビリティの3本柱の統合的理解

### 3.3. フェーズ3: OpenTelemetryと高度なモニタリング (週11-14)

#### 3.3.1. 目標

- AWS SDK v2からOpenTelemetryへの移行
- 高度なモニタリング手法の実装
- 実ユーザーモニタリング（RUM）と合成モニタリングの実装
- アラートと異常検出の設定
- スケルトンUIなどのUX向上技術の実装

#### 3.3.2. 技術的成果物

- OpenTelemetry統合システム
- ADOT Collector設定
- AWS SDK v2との比較分析
- RUMとWeb Vitals計測
- 合成モニタリング設定
- アラートと異常検出システム
- スケルトンローダーコンポーネント
- 自動テストと検証フロー

#### 3.3.3. 習得するスキル

- OpenTelemetryの概念と設定
- AWS SDK v2からOpenTelemetryへの移行手法
- RUMと合成モニタリングの実装技術
- アラート設計のベストプラクティス
- 異常検出の設定と調整
- UXパフォーマンス最適化手法
- スケルトンUIの設計と実装

### 3.4. フェーズ4: 顧客認証と注文機能 (週15-19)

#### 3.4.1. 目標

- 顧客向け認証システムの実装
- ソーシャルログイン連携の実装
- カート機能と認証連携の実装
- 注文処理システムの実装
- 注文関連イベント処理の実装
- 認証・注文フローの包括的オブザーバビリティ

#### 3.4.2. 技術的成果物

- 顧客認証システム（ソーシャルログイン連携含む）
- 完全なカートシステム
- 注文処理システム
- イベント駆動型アーキテクチャ
- エンドツーエンドのオブザーバビリティ
- 認証セキュリティモニタリング
- 複数ステップフォームの実装

#### 3.4.3. 習得するスキル

- 認証システムの設計と実装
- OAuth/OIDC認証の実装
- カートと注文システムの設計
- 複数ステップフォームの実装
- イベント駆動型アーキテクチャの拡張
- エンドツーエンドトレースの実装
- 認証セキュリティのモニタリング

### 3.5. フェーズ5: 管理認証と管理機能 (週20-23)

#### 3.5.1. 目標

- 管理者向け認証・権限システムの実装
- 商品・在庫管理機能の拡張と権限連携
- 管理機能の包括的モニタリングの実装
- ビジネスメトリクスと技術メトリクスの統合
- 包括的なオブザーバビリティダッシュボードの作成

#### 3.5.2. 技術的成果物

- 管理者認証と権限管理システム
- 高度な商品管理システム
- 在庫管理システム
- RBAC（ロールベースアクセス制御）
- 管理操作の監査ログシステム
- 包括的モニタリングダッシュボード
- オブザーバビリティデータの統合分析

#### 3.5.3. 習得するスキル

- RBAC（ロールベースアクセス制御）の設計と実装
- 多要素認証（MFA）の実装
- 監査ログシステムの設計
- 商品・在庫管理システムの高度な実装
- 管理機能のオブザーバビリティ設計
- ダッシュボード設計と実装
- データの相関分析手法

### 3.6. フェーズ6: 本番環境と耐障害性 (週24-25)

#### 3.6.1. 目標

- AWS環境への本番デプロイ
- CI/CDパイプラインの構築
- 障害テストと復旧手順の確立
- パフォーマンス最適化
- カオスエンジニアリングの実践

#### 3.6.2. 技術的成果物

- 本番環境デプロイ構成（Terraform）
- CI/CDパイプライン
- AWS Fault Injection Service設定
- 障害シナリオとテスト結果
- 耐障害性のレポート
- パフォーマンス最適化の実施

#### 3.6.3. 習得するスキル

- Terraformによるインフラのコード化
- CI/CDパイプラインの設計と実装
- AWS Fault Injection Serviceの利用
- カオスエンジニアリングの実践
- 耐障害性の評価と強化
- パフォーマンス最適化手法
- 本番環境でのオブザーバビリティ設定

## 4. 技術的考察

### 4.1. AWS SDK v2とOpenTelemetryの比較学習

#### 4.1.1. 段階的移行アプローチ

このプロジェクトでは、まずAWS SDK v2でオブザーバビリティを実装し、その後OpenTelemetryに移行することで、両者の比較学習が可能になります。この段階的アプローチにより、AWS固有のサービスから標準的なOpenTelemetryへの移行経験を得ることができます。

具体的な移行ステップ：

1. **フェーズ2**でAWS SDK v2による基本実装
   - CloudWatchとX-Rayの直接統合
   - AWSネイティブなオブザーバビリティを学習

2. **フェーズ3**でOpenTelemetryへの移行
   - ADOT Collectorの導入
   - SDK実装の変更
   - データ変換とエクスポート設定

3. **フェーズ3-6**でOpenTelemetryの活用
   - より高度な機能の実装
   - マルチクラウド対応の考慮
   - オープンソースツールとの連携

#### 4.1.2. 比較ポイント

AWS SDK v2とOpenTelemetryを比較する際の主要なポイント：

| 比較項目           | AWS SDK v2アプローチ            | OpenTelemetryアプローチ                    |
| ------------------ | ------------------------------- | ------------------------------------------ |
| **セットアップ**   | AWSサービスとの直接統合で簡単   | 追加コンポーネント(Collector)が必要        |
| **柔軟性**         | AWS環境に最適化されるが制限あり | クラウド間、オープンソースツールと連携可能 |
| **標準化**         | AWS固有の実装                   | OpenTelemetry標準に準拠                    |
| **運用コスト**     | 低め（AWSサービスのみ）         | やや高め（追加コンポーネント運用）         |
| **機能の豊富さ**   | AWSサービスに最適化             | 汎用的で拡張性が高い                       |
| **学習曲線**       | AWSユーザーには馴染みやすい     | より広範な知識が必要                       |
| **ベンダーロック** | 高い（AWS依存）                 | 低い（標準規格）                           |
| **コミュニティ**   | AWSサポート中心                 | 大規模なオープンソースコミュニティ         |

#### 4.1.3. 移行戦略

AWS SDK v2からOpenTelemetryへの効率的な移行戦略：

1. **並行実行期間の設定**
   - 一定期間、両方のシステムを並行稼働させる
   - データの整合性を確認
   - 機能の等価性を検証

2. **コンポーネント別の段階的移行**
   - トレース→メトリクス→ログの順で移行
   - 各段階で十分なテストと検証

3. **共通インターフェースの設計**
   - 抽象化レイヤーを設けて実装の切り替えを容易に
   - 設定ベースで動作を制御

4. **移行の自動検証**
   - 両システムのデータ比較の自動化
   - 差異の検出と分析
   - パフォーマンス影響の計測

### 4.2. オブザーバビリティの3本柱の統合学習

#### 4.2.1. 統合アプローチの利点

オブザーバビリティの3本柱（ログ、メトリクス、トレース）を統合的に学習することで、以下の利点があります：

1. **包括的な視点の獲得**
   - システム全体の状態を多角的に理解できる
   - 問題の根本原因をより迅速に特定できる
   - データ間の相関関係を活用できる

2. **コンテキスト情報の共有**
   - リクエストIDなどの共通識別子で情報を関連付け
   - ユーザー体験からインフラ問題までを追跡可能
   - イベントの時間的順序を正確に把握

3. **効率的なデバッグと問題解決**
   - 複数のデータソースから証拠を収集
   - パターン認識によるトラブルシューティング
   - 再発防止のための根本原因分析

#### 4.2.2. 実践的な統合ポイント

このプロジェクトでの3本柱統合のための実践ポイント：

1. **共通識別子の一貫した利用**
   - トレースID、スパンID、リクエストIDの伝播
   - ユーザーセッションIDの維持
   - サービス名とインスタンス識別子の標準化

2. **時間同期の確保**
   - 正確なタイムスタンプの記録
   - タイムゾーンの標準化
   - 時系列データの整合性維持

3. **データモデルの一貫性**
   - 一貫した命名規則
   - 共通のタグとラベル
   - 属性の標準化

4. **可視化ツールの統合**
   - 複数データソースを1つのダッシュボードに表示
   - クロスリンクによるコンテキスト切替
   - 相関ビューの作成

#### 4.2.3. 相関分析の実装

異なるデータソース間の相関分析の実装方法：

1. **トレースからログへの橋渡し**
   - トレースIDをログに埋め込む
   - ログエントリにスパンIDを含める
   - トレースビューアからログへのディープリンク

2. **メトリクスからトレースへの関連付け**
   - 異常なメトリクスからのトレース検索
   - メトリクスからのトレースサンプリング
   - トレースに基づくメトリクス生成

3. **ログからメトリクスへの変換**
   - ログパターンに基づくメトリクス生成
   - エラーログからのアラート設定
   - ログベースのKPI監視

4. **統合クエリと分析**
   - CloudWatch Logs Insightsの高度なクエリ
   - X-Rayトレース分析
   - OpenTelemetryの相関分析

### 4.3. サーバーレスのオブザーバビリティ

#### 4.3.1. サーバーレス固有の課題

サーバーレス環境でのオブザーバビリティには従来と異なる課題があります：

1. **コールドスタートの影響**
   - 初回起動時のレイテンシー増加
   - オブザーバビリティ設定のオーバーヘッド
   - コールドスタート頻度の計測と最適化

2. **短命なプロセス**
   - 実行時間が短いため情報収集の機会が限られる
   - 処理の完全な記録が重要
   - コンテキスト情報の効率的な収集

3. **分散処理の複雑さ**
   - 非同期イベントチェーンの追跡
   - マイクロサービス間の依存関係把握
   - エラー伝播の追跡

4. **リソース制約**
   - メモリとCPU制限内での動作
   - オブザーバビリティのオーバーヘッド最小化
   - コスト効率の最適化

#### 4.3.2. モニタリング戦略

サーバーレスのための効果的なモニタリング戦略：

1. **モニタリングスコープの定義**
   - ビジネスクリティカルな関数の特定
   - SLIとSLOの設定
   - 重要なトランザクションパスの定義

2. **マルチレイヤーの観測**
   - 関数レベルのメトリクス
   - イベントチェーンのトレース
   - リソース使用状況の監視
   - ユーザー体験の計測

3. **バッチ処理の最適化**
   - テレメトリーデータのバッチ送信
   - 信頼性の高い配信保証
   - リソース使用の平準化

4. **エラーと例外の包括的追跡**
   - すべての例外のログ記録
   - エラータイプの分類
   - 障害パターンの検出
   - 自動リカバリーの監視

#### 4.3.3. 実装手法

サーバーレスのオブザーバビリティ実装のベストプラクティス：

1. **Lambda固有の最適化**
   - 初期化コードと実行コードの分離
   - グローバル変数の効果的な利用
   - コンテキスト情報の効率的な抽出

2. **イベント駆動モニタリング**
   - EventBridgeによるイベントモニタリング
   - 非同期ワークフローの可視化
   - イベント相関IDの伝播

3. **効率的なトレース実装**
   - X-Ray Active Tracingの有効化
   - カスタムサブセグメントの限定的使用
   - サンプリングルールの最適化

4. **統合コンソールの活用**
   - AWS Lambda Consoleでの監視
   - CloudWatch Logs Insightsの活用
   - X-Rayトレースマップの活用
   - Lambda Insightsの有効活用

## 5. 詳細実装計画

### 5.1. 週1: プロジェクト基盤構築

#### 5.1.1. 学習目標

- Docker Compose、Go/Echo、Next.js環境のセットアップ
- プロジェクト構造とGitHub管理の理解
- JavaScript/TypeScriptの基本構文の把握
- 基本的なミドルウェアとルーティングの実装
- ヘルスチェックAPIの設計と実装

#### 5.1.2. 実装タスク

1. Docker Compose環境の構築（MySQL、Traefik、LocalStack）
2. Go/Echo開発環境の準備と基本構造実装
   - ディレクトリ構造とパッケージ設計
   - 基本的なミドルウェア設定
   - 設定管理モジュールの実装
   - ホットリロード設定（air for Go）
3. Next.js/TypeScript/TailwindCSSプロジェクト作成
   - プロジェクト構成
   - 基本レイアウトの設計
   - API通信用のクライアント基本設定
   - ホットリロード設定（Next.js dev server）
4. ヘルスチェックAPIの実装
5. ESLintとPrettierの設定
6. go-taskによるタスクランナーの設定
7. GitHubリポジトリのセットアップとワークフロー設定

#### 5.1.3. フロントエンド学習

- TypeScriptの基本型とES6+の機能
  - 型注釈と型推論
  - インターフェースと型定義
  - ジェネリクス入門
- Next.jsプロジェクト構造の理解
  - pages, public, stylesディレクトリ
  - _app.js, _document.jsの役割
  - APIルートの基本
- モジュールシステムと依存関係管理
  - import/exportの仕組み
  - package.jsonの理解
  - npmとyarnの基本コマンド

#### 5.1.4. チェックポイント

- [ ] Docker Composeが正常に動作し、各サービスが起動できる
- [ ] バックエンドのヘルスチェックAPIへアクセスできる
- [ ] フロントエンドの基本ページが表示される
- [ ] `.gitignore`や`package.json`が適切に設定されている
- [ ] LocalStackが正常に動作している
- [ ] Traefikによるルーティングが機能している

#### 5.1.5. 自己評価基準

- Docker、Git、Node.js、Goの基本コマンドを理解できたか
- プロジェクト構造の意図と設計原則を説明できるか
- TypeScriptとES6+の主要機能を説明できるか
- 開発環境をゼロから構築し直せるか
- 基本的なルーティングとミドルウェアの仕組みを理解できたか

### 5.2. 週2: データモデルと基本API

#### 5.2.1. 学習目標

- データベーススキーマの設計と実装方法の習得
- sqlboilerによるORM設定の理解
- golang-migrateによるマイグレーション管理
- OpenAPI仕様の基本概念の理解
- Reactの基本的な概念とJSXの理解
- サーバーレスアーキテクチャの基本概念の把握

#### 5.2.2. 実装タスク

1. MySQLテーブル設計と`golang-migrate`による実装
   - 商品、カテゴリー、在庫情報のテーブル設計
   - マイグレーションスクリプトの作成
   - テストデータの準備
2. sqlboilerの設定とモデル生成
   - 設定ファイルの作成
   - モデル生成スクリプトの準備
   - 基本的なクエリビルダーの使用法
3. 基本的なデータアクセスレイヤーの実装
   - リポジトリパターンの導入
   - トランザクション管理の設計
4. OpenAPI仕様の初期定義と基本APIの設計
   - API定義ファイルの作成
   - 商品関連APIの定義
   - oapi-codegenによるコード生成
5. トランザクション管理の基本設計
6. サーバーレスアーキテクチャの概要理解とLocalStackでのLambda環境の基本設定
7. OpenAPI仕様の詳細化とSwagger UIの導入

#### 5.2.3. フロントエンド学習

- Reactコンポーネントのライフサイクル
  - 関数コンポーネントとクラスコンポーネント
  - useEffectの基本的な使い方
  - コンポーネントのマウント/アンマウント
- JSXの構文とHTML/CSSとの違い
  - JSXの基本構文
  - 条件付きレンダリング
  - リストのレンダリング
- propsとイベントハンドリングの基礎
  - propsの渡し方
  - イベントハンドラの設定
  - コンポーネント間のデータ受け渡し

#### 5.2.4. チェックポイント

- [ ] MySQLに基本テーブル（products, categories）が作成されている
- [ ] sqlboilerで生成したモデルを使ってデータアクセスができる
- [ ] 基本的なAPIエンドポイントの仕様が定義されている
- [ ] Swagger UIでAPI仕様を閲覧できる
- [ ] シンプルなエラーハンドリングが実装されている
- [ ] LocalStackでLambdaとS3が設定されている
- [ ] Reactコンポーネントを作成できる

#### 5.2.5. 自己評価基準

- データベース設計の基本原則を理解し、適切なスキーマを作成できたか
- ORMの役割と利点を説明できるか
- OpenAPI仕様の利点とAPI設計手法を理解できたか
- サーバーレスアーキテクチャの基本概念を説明できるか
- Reactの基本概念とコンポーネント設計を説明できるか
- トランザクション管理の原則と実装を理解できたか

### 5.3. 週3: 商品カタログバックエンドの完成

#### 5.3.1. 学習目標

- バックエンドAPIの設計と実装パターンの習得
- バリデーションとエラーハンドリングの理解
- テスト駆動開発の基本的な手法の習得
- Next.jsの基本構造とルーティングの理解
- 基本的なサーバーレス関数の実装方法の習得

#### 5.3.2. 実装タスク

1. 商品一覧API（ページネーション対応）の実装
   - クエリパラメータによるフィルタリング
   - ページネーション処理
   - レスポンス形式の標準化
2. 商品詳細API、カテゴリー別商品一覧APIの実装
   - URLパラメータでのリソース取得
   - 関連データの取得
   - エラー処理
3. シンプルな画像処理Lambda実装
   - 商品画像リサイズLambda関数の実装
   - S3トリガーの設定
   - 処理結果の保存
   - エラーハンドリング
4. S3を使った商品画像の保存と取得機能
   - S3バケットへの画像アップロード
   - 画像URLのデータベース連携
   - 画像取得APIの実装
   - LocalStackでのS3エミュレーション設定
5. 入力バリデーションとエラーハンドリングの実装
   - バリデーションルールの定義
   - エラーレスポンスの統一
   - グローバルエラーハンドラ
6. ユニットテストとテーブル駆動テストの実装
   - テストケースの設計
   - モックの活用
   - カバレッジの測定
7. Next.jsの基本ルーティング設定

#### 5.3.3. フロントエンド学習

- Next.jsのファイルベースルーティング
  - ページとルートの関係
  - 動的ルーティング
  - ネストされたルート
- データフェッチの基本パターン
  - getServerSideProps
  - getStaticProps
  - SWRの基本概念
- レイアウトコンポーネントの使用方法
  - コンポーネント合成
  - レイアウトの共有
  - ページトランジション

#### 5.3.4. チェックポイント

- [ ] 商品APIがページネーション、フィルタリングに対応している
- [ ] エラー時に適切なレスポンスを返す
- [ ] テストカバレッジが70%以上ある
- [ ] Next.jsの複数ページが正しくルーティングされる
- [ ] Lambda関数が商品画像をリサイズできる
- [ ] S3バケットに画像をアップロード/ダウンロードできる
- [ ] 商品データとS3画像URLが連携している

#### 5.3.5. 自己評価基準

- RESTful APIの設計原則に従って実装できたか
- エラー処理を体系的に行えているか
- テスト駆動開発の利点を理解し実践できたか
- Next.jsのルーティングシステムを説明できるか
- 商品画像処理の基本的なサーバーレスパイプラインを構築できたか
- バリデーションとエラーハンドリングの重要性を理解し実装できたか

### 5.4. 週4: 顧客向け商品閲覧UI

#### 5.4.1. 学習目標

- Reactコンポーネントの設計と実装の習得
- Next.jsでのデータフェッチングパターンの理解
- コンポーネント間のデータ受け渡しの理解
- コンポーネントの再利用性とProps設計の習得
- フロントエンドでのバリデーションとエラー表示の実装方法の理解

#### 5.4.2. 実装タスク

1. 商品一覧ページの実装（API連携、ページネーション）
   - 商品リスト表示
   - ページネーションコントロール
   - ロード状態表示
2. 商品カードコンポーネントの作成
   - レスポンシブデザイン
   - 画像表示の最適化
   - イベントハンドリング
3. 商品詳細ページの実装
   - 詳細情報表示
   - 在庫状況表示
   - 関連商品表示
   - 画像表示の最適化
4. 商品検索APIの実装
5. カテゴリーナビゲーションの実装
   - カテゴリー一覧表示
   - フィルタリング機能
   - パンくずナビゲーション
   - レスポンシブ対応
6. ローディング状態とエラー状態の表示実装
7. 検索フォームのバリデーションとユーザーフィードバック実装
8. APIエラーの適切な処理と表示
9. フロントエンドのテスト実装
   - Reactコンポーネントのユニットテスト
   - Next.jsページのテスト
   - モックAPIレスポンスの設定
   - スナップショットテスト

#### 5.4.3. フロントエンド学習

- 再利用可能なコンポーネント設計
  - 責務の分離
  - 適切な粒度の決定
  - コンポーネントライブラリの設計思想
- TypeScriptでのPropsの型定義
  - インターフェースの活用
  - オプショナルプロパティ
  - 共通型の設計
- コンポーネント合成パターン
  - Childrenの活用
  - Renderプロパティ
  - 高階コンポーネント
- 条件付きレンダリング
  - 三項演算子の使用
  - 論理演算子を使ったショートサーキット
  - switch文の活用
- フォーム入力の基本的なバリデーション
  - 制御されたコンポーネント
  - フォーム状態の管理
  - エラーメッセージの表示

#### 5.4.4. チェックポイント

- [ ] 商品一覧ページがAPIからデータを取得して表示できる
- [ ] ページネーションが機能している
- [ ] カテゴリーフィルタリングが機能している
- [ ] 商品詳細ページが実装されている
- [ ] コンポーネントに適切な型定義がされている
- [ ] 検索フォームで無効な入力時に適切なフィードバックがある
- [ ] APIエラー時にユーザーフレンドリーなメッセージが表示される

#### 5.4.5. 自己評価基準

- Reactコンポーネントの責務分離を適切に行えたか
- Propsの設計が適切で型安全か
- データフェッチングのパターンを理解し実装できたか
- エラー状態やローディング状態を適切に処理しているか
- ユーザー体験を考慮したエラー処理とバリデーションを実装できたか
- コンポーネントの再利用性と保守性を意識した設計ができているか

### 5.5. 週5: TailwindCSSとスタイリング・管理画面の基本実装

#### 5.5.1. 学習目標

- TailwindCSSの基本概念と使用方法の習得
- レスポンシブデザインの実装方法の理解
- 管理画面の基本レイアウト設計の習得
- ダークモード対応などの高度なスタイリングの理解
- 管理画面でのバリデーションとエラー処理の実装方法の理解

#### 5.5.2. 実装タスク

1. TailwindCSSを使った基本スタイルの適用
   - 設定ファイルのカスタマイズ
   - ユーティリティクラスの活用
   - 共通スタイルの抽出
2. レスポンシブな商品一覧グリッドの作成
   - ブレークポイントの設定
   - グリッドレイアウトの実装
   - フレックスボックスの活用
3. 管理画面の基本レイアウト実装
   - サイドバーナビゲーション
   - ヘッダー/フッター
   - ダッシュボードレイアウト
4. 商品管理の基本画面実装（一覧表示、検索機能）
   - テーブルレイアウト
   - 検索/フィルタリングUI
   - 簡易編集機能の実装
   - 商品詳細閲覧
5. カテゴリー管理の基本画面実装
   - カテゴリー一覧の表示
   - カテゴリー操作UIの実装
   - 階層構造の表示
   - ドラッグ&ドロップの基本設定
6. モック認証システムの実装
   - ログイン画面
   - JWT基本設定
   - 認証状態管理
   - 保護されたルート
7. 管理操作のバリデーションと適切なフィードバックの実装
8. 権限エラーやAPI失敗時の適切なエラー表示

#### 5.5.3. フロントエンド学習

- ユーティリティファーストCSSの概念
  - ユーティリティクラスvs従来のCSS
  - TailwindCSSの設計哲学
  - 一貫性とカスタマイズのバランス
- FlexboxとGridレイアウトの使い分け
  - 1次元vs2次元レイアウト
  - アイテムの配置と整列
  - ギャップと間隔の調整
- レスポンシブブレークポイントの設定
  - モバイルファースト設計
  - カスタムブレークポイント
  - 条件付きスタイリング
- コンポーネント間のスペーシングとマージン
  - 外部vs内部マージン
  - 一貫したスペーシングシステム
  - ネガティブスペーシング
- 管理機能における入力検証とエラー処理のベストプラクティス
  - 管理者向けエラーメッセージ
  - バリデーションのタイミング
  - フォームのユーザビリティ

#### 5.5.4. チェックポイント

- [ ] TailwindCSSを使用したスタイリングが適用されている
- [ ] レスポンシブデザインが実装されている
- [ ] 管理画面のレイアウトが整っている
- [ ] 商品一覧が管理画面で表示される
- [ ] モック認証機能で保護されたルートが機能する
- [ ] 入力フォームに適切なバリデーションが実装されている
- [ ] 操作の成功/失敗が明確にユーザーに通知される

#### 5.5.5. 自己評価基準

- TailwindCSSの基本概念とユーティリティクラスを理解しているか
- レスポンシブデザインの原則を理解し実装できたか
- 管理画面のUXが直感的で使いやすいか
- 基本的な認証フローを実装できたか
- 管理操作の安全性とユーザー体験を両立したバリデーションを実装できたか
- コンポーネントのスタイリングに一貫性があるか

### 5.6. 週6: ログ基盤の構築

#### 5.6.1. 学習目標

- 構造化ログの概念と実装方法の深い理解
- ログレベル管理の原則と実践方法の習得
- コンテキスト情報とログの関連付けの理解
- LocalStackとAWS CLIの基本操作の習得
- CloudWatch Logsの概念と基本アーキテクチャの理解
- ログ転送とバッチ処理の実装方法の習得

#### 5.6.2. 実装タスク

1. ログの基本概念と3本柱における位置づけの学習
2. 構造化ログとフラットログの比較検討
   - slogを使用した高度な構造化ログ設計
   - JSONフォーマッターの設定
   - カスタムログハンドラーの実装
   - コンテキスト情報の伝播設計
3. slogを使用した構造化ログ設計の実装
   - ログフォーマッターの設定
   - ログレベルの設定
   - 詳細ログとサンプリングの設計
   - エラーログの強化
   - コンテキスト情報の追加
4. ログレベル管理（ERROR/WARN/INFO/DEBUG）の実装
   - 環境別設定
   - 動的レベル変更
   - 適切なレベル使用ガイドライン
5. ミドルウェアを使用したリクエスト/レスポンスのログ記録
6. LocalStack用CloudWatch Logsリソース定義（Terraform）
   - LocalStack用の基本設定
   - CloudWatch Logs用のリソース定義
   - IAMロールとポリシーの設定
   - ログ保持期間の設定
7. slogカスタムハンドラーの実装（CloudWatch Logs対応）
8. コンテキスト情報の伝播設計の実装
9. CloudWatch Logsへのログ転送（バッチ処理）
   - CloudWatch Logsエージェントの設定
   - バッチ処理の最適化
   - フィルタリングとサンプリングの実装
   - エラー処理と再試行ロジック

#### 5.6.3. フロントエンド学習

- fetch APIとPromiseの基本
  - Promiseの概念
  - 非同期データ取得
  - エラーハンドリング
- async/awaitを使った非同期処理
  - 同期的コードスタイル
  - エラーハンドリング
  - Promiseチェーンとの比較
- try-catchによるエラーハンドリング
  - エラー捕捉
  - エラー種別の判別
  - エラー情報の表示
- ローディング状態の管理
  - 状態フラグ
  - スケルトンUI
  - タイムアウト処理

#### 5.6.4. チェックポイント

- [ ] 構造化ログが正しい形式（JSON）で出力される
- [ ] ログレベルに応じて適切にログが記録される
- [ ] リクエスト/レスポンスのログが適切に記録されている
- [ ] LocalStackにCloudWatch Logsリソースが作成されている
- [ ] アプリケーションログがCloudWatch Logsに転送される
- [ ] リクエストIDなどのコンテキスト情報がログに含まれる
- [ ] バッチ処理が効率的に行われている

#### 5.6.5. 自己評価基準

- 構造化ログの利点と実装方法を理解できたか
- ログレベルの適切な使い分けを説明できるか
- CloudWatch Logsの仕組みと利点を説明できるか
- コンテキスト情報の伝播の重要性を理解しているか
- エラー発生時のフォールバックメカニズムを実装できたか
- 非同期プログラミングの基本概念を理解しているか
- ログ収集の効率性とパフォーマンスのバランスを考慮できたか

### 5.7. 週7: メトリクス収集システムの実装

#### 5.7.1. 学習目標

- メトリクスの種類と役割の理解
- CloudWatch Metricsの基本概念と使用方法の習得
- メトリクス設計の原則と実装方法の理解
- SWRによるデータ管理の理解
- データキャッシュと再検証の概念の把握

#### 5.7.2. 実装タスク

1. メトリクスの基本概念と3本柱における位置づけの学習
2. メトリクスの種類とユースケースの理解
   - カウンター
   - ゲージ
   - ヒストグラム
   - サマリー
3. CloudWatch Metricsリソース設定（Terraform）
   - CloudWatch Metricsリソースの設定
   - カスタムメトリクス名前空間の設計
   - ディメンション設計
   - メトリクスフィルターの設定
4. 基本メトリクス収集の実装（リクエスト数、レイテンシー、エラー率）
   - リクエスト数、レイテンシー、エラー率の計測
   - インフラメトリクス（CPU、メモリ、ディスクI/O）の収集
   - データベース関連メトリクスの設定
   - パーセンタイル計測の実装
5. 効果的なメトリクス設計の原則
6. メトリクス収集の頻度とコスト考慮
   - CloudWatch Dashboardsの基本設定
   - REDダッシュボードの作成
   - システム健全性ダッシュボード
   - ビジネスダッシュボードの基本設計
7. インフラメトリクス（CPU、メモリ、ディスクI/O）の収集
8. ビジネスメトリクスの設計と実装
   - ビジネスプロセスの計測ポイント特定
   - 商品閲覧、検索、カテゴリーナビゲーションの計測
   - ユーザーセッションの分析メトリクス
   - コンバージョンパス分析の基礎
9. メトリクスダッシュボードの作成
10. SWRを使った商品データの取得実装

#### 5.7.3. フロントエンド学習

- SWRの基本概念と設定
  - useSWRフックの使用法
  - グローバル設定
  - カスタムフェッチャー
- データの取得、キャッシュ、再検証
  - キャッシュ戦略
  - 再検証タイミング
  - ステール・ワイル・リバリデート
- 条件付きフェッチング
  - 依存関係による制御
  - キー変更による再フェッチ
  - ポーリングとリアルタイム更新
- エラー処理とリトライ
  - エラー状態の管理
  - 自動リトライ
  - フォールバックデータ

#### 5.7.4. チェックポイント

- [ ] アプリケーションの基本メトリクスがCloudWatchに送信される
- [ ] インフラメトリクスが収集されている
- [ ] ビジネスメトリクス（商品閲覧数など）が計測されている
- [ ] メトリクスダッシュボードで可視化されている
- [ ] SWRを使ったデータ取得が実装されている
- [ ] データキャッシュと再検証が機能している
- [ ] カスタムディメンションでメトリクスがフィルタリングできる

#### 5.7.5. 自己評価基準

- メトリクス設計の原則を理解しているか
- 技術メトリクスとビジネスメトリクスの違いを説明できるか
- ダッシュボード設計が効果的か
- SWRのメリットとユースケースを理解しているか
- メトリクス収集の頻度とコスト考慮ができているか
- REDメソッド（Rate, Errors, Duration）を理解し実装できているか
- メトリクスを使った異常検出の基本概念を理解しているか

### 5.8. 週8: 分散トレースの実装

#### 5.8.1. 学習目標

- X-Rayの概念とアーキテクチャの理解
- 分散トレースの基本原則と実装方法の習得
- エラーハンドリングとフォールバックUIの実装方法の理解
- Reactのエラー境界の概念と使用方法の習得

#### 5.8.2. 実装タスク

1. X-Rayリソース設定（Terraform）
   - X-Rayリソースの設定
   - サンプリングルール
   - グループの設定
   - アノテーションとメタデータの設計
2. X-Ray SDK for Go v2の統合
   - セグメントの作成
   - セグメントとサブセグメントの設計
   - エラー情報の追加
3. Echoミドルウェアのトレース設定
   - リクエスト/レスポンストレース
   - エラートレース
   - カスタムアノテーション
4. データベースクエリのトレース実装
   - sqlboilerのトレース統合
   - クエリパフォーマンストレース
   - カスタムサブセグメントの追加
   - トランザクショントレース
5. フロントエンドのエラー境界コンポーネント実装
   - エラー境界設定
   - フォールバックUI
   - エラーログ
6. トレースマップの設定とフィルター作成
7. トレース分析クエリの作成

#### 5.8.3. フロントエンド学習

- Reactのエラー境界（Error Boundaries）
  - クラスコンポーネントでの実装
  - エラーキャッチの範囲
  - ライフサイクルメソッド
- グローバルエラーハンドリング
  - イベントハンドラでのエラー捕捉
  - 非同期エラーの処理
  - グローバルエラーハンドラ
- フォールバックUIの設計
  - ユーザーフレンドリーな表示
  - 再試行メカニズム
  - コンテキスト保存
- エラータイプの分類と対応
  - ネットワークエラー
  - バリデーションエラー
  - 認証エラー
  - サーバーエラー

#### 5.8.4. チェックポイント

- [ ] X-Rayトレースがアプリケーションで収集されている
- [ ] リクエスト処理の各段階がトレースされている
- [ ] データベースクエリがサブセグメントとして記録される
- [ ] フロントエンドでエラー境界が実装されている
- [ ] ユーザーフレンドリーなエラーUIが表示される
- [ ] トレースマップとフィルターが設定されている
- [ ] トレース情報にカスタムアノテーションが含まれている

#### 5.8.5. 自己評価基準

- 分散トレースの目的と利点を説明できるか
- X-Rayの基本概念とセグメント/サブセグメントを理解しているか
- トレースデータの分析方法を理解しているか
- エラー処理の階層的アプローチを実装できたか
- トレースとログ、メトリクスとの関連性を理解しているか
- サンプリングルールとその影響を説明できるか
- ユーザー体験を考慮したエラーUIを設計できたか

### 5.9. 週9: 高度なサーバーレス機能の実装

#### 5.9.1. 学習目標

- イベント駆動型アーキテクチャの原則の習得
- 高度なLambda関数の設計とパフォーマンス最適化の理解
- Lambda間連携パターンの把握
- 状態管理の基礎とコンテキスト管理の理解
- Reactの状態管理パターンの把握

#### 5.9.2. 実装タスク

1. イベント駆動型アーキテクチャの設計実装
   - イベント構造の設計
   - イベント発行/購読の実装
   - イベントハンドラの実装
2. SNSトピックとSQSキューの設定
   - SNSトピック作成
   - SQSキュー設定
   - サブスクリプション設定
3. 高度なLambda関数の実装（コールドスタート最適化、Layers活用）
   - 初期化コードの最適化
   - 共通コードのLayer化
   - 環境変数の活用
   - コールドスタート最適化
   - パフォーマンスチューニング
4. 複雑なバッチ処理Lambda実装（在庫レポート生成）
   - 定期実行の設定
   - データ処理ロジック
   - レポート生成と保存
   - CloudWatch Eventsトリガー設定
   - データエクスポート機能
   - 非同期処理の設計
5. Lambda関数チェーンとStep Functionsによるワークフロー実装
   - ステートマシン設計
   - 条件分岐
   - ファンアウト/ファンインパターン
   - デッドレターキューの実装
   - エラーハンドリング
6. デッドレターキューの設定
7. フロントエンドの状態管理実装（商品フィルター）

#### 5.9.3. フロントエンド学習

- useState vs useReducer
  - 単純vs複雑な状態
  - アクションベースの状態更新
  - パフォーマンス考慮点
- React Contextの使用方法
  - Contextの作成
  - Providerとコンシューマー
  - パフォーマンスへの影響
- 状態リフトアップのパターン
  - 共有状態の管理
  - 親子コンポーネント間の状態連携
  - 過剰なprops drilling回避
- 不変性（immutability）の重要性
  - 参照型データの更新
  - スプレッド構文の活用
  - イミュータブルな更新パターン

#### 5.9.4. チェックポイント

- [ ] イベント駆動型アーキテクチャが実装されている
- [ ] SNSトピックとSQSキューが設定されている
- [ ] 高度なLambda関数が実装されている
- [ ] バッチ処理Lambda関数が定期的に実行される
- [ ] Lambda関数間の連携が機能している
- [ ] フロントエンドで状態管理が実装されている
- [ ] カテゴリーフィルタリングが状態管理を使って実装されている

#### 5.9.5. 自己評価基準

- イベント駆動型アーキテクチャの利点と実装方法を説明できるか
- Lambda関数の最適化テクニックを理解しているか
- SNS/SQSの役割と設定方法を理解しているか
- 複雑なワークフローを設計・実装できるか
- Reactの状態管理パターンを適切に選択できるか
- エラー処理と回復メカニズムを組み込めているか
- イベントソーシングの基本概念を理解しているか

### 5.10. 週10: サーバーレスオブザーバビリティとカスタムフック

#### 5.10.1. 学習目標

- サーバーレス環境におけるオブザーバビリティの特殊性の理解
- Lambda固有のメトリクスとログの収集方法の習得
- カスタムフックの設計と実装方法の理解
- ロジック再利用パターンの習得

#### 5.10.2. 実装タスク

1. Lambda実行ログの構造化実装
   - Lambda用ログハンドラーの実装
   - カスタムログフォーマッター
   - リクエスト/レスポンスのログ記録
   - コンテキスト情報の付加
   - エラー情報の強化
2. Lambda固有メトリクスの収集（実行時間、メモリ使用量）
   - 実行時間、メモリ使用量の計測
   - コールドスタート検出と計測
   - エラー率の計測
   - カスタムメトリクス生成
   - CloudWatchメトリクス送信
   - パフォーマンス計測
3. Lambda Insightsの設定
   - Lambda Insightsの有効化
   - パフォーマンスプロファイリングの設定
   - メモリプロファイリング
   - 拡張機能の有効化
   - カスタムダッシュボード
   - 異常検出の基本設定
   - アラート設定
4. サーバーレストレースの実装
   - X-RayでのLambdaトレース設定
   - イベント処理フローのトレース
   - 非同期処理のトレース連鎖
   - サービス間トレースの連携
   - SNS/SQSとの連携トレース
   - バッチ処理のトレース
5. フロントエンドでのカスタムフックの実装
   - データフェッチフック
   - フォーム状態管理フック
   - 再利用可能なロジックのフック化

#### 5.10.3. フロントエンド学習

- カスタムフックの設計パターン
  - 関心の分離
  - ビジネスロジックのカプセル化
  - カスタムフックの命名規則
- ロジックの抽象化と再利用
  - ユースケースの特定
  - インターフェース設計
  - 汎用性と特殊性のバランス
- テスト可能なフックの設計
  - 依存関係の注入
  - サイドエフェクトの分離
  - テストフレームワークとの統合
- ブラウザAPI利用のカスタムフック
  - localStorage/sessionStorage
  - Geolocation API
  - MediaQueryList API

#### 5.10.4. チェックポイント

- [ ] Lambda関数のログが構造化されている
- [ ] Lambda固有メトリクスが収集されている
- [ ] Lambda Insightsが有効化されている
- [ ] Lambda関数の実行がトレースされている
- [ ] フロントエンドでカスタムフックが実装されている
- [ ] ロジックの再利用性が高まっている
- [ ] サーバーレスアプリケーションの観測性が向上している

#### 5.10.5. 自己評価基準

- サーバーレス環境の監視における課題と解決策を説明できるか
- Lambda固有のメトリクスの重要性を理解しているか
- Lambda Insightsの提供する情報を活用できるか
- カスタムフックの設計原則に従って実装できたか
- コード重複を効果的に削減できたか
- サーバーレス関数のパフォーマンス特性を理解しているか
- Lambda関数間の関係性を可視化できるか

### 5.11. 週11: OpenTelemetry基盤の構築

#### 5.11.1. 学習目標

- OpenTelemetryの基本概念とアーキテクチャの理解
- ADOT Collectorの設定と使用方法の習得
- クライアントサイドのログ収集理解
- フロントエンドでのログ収集と送信方法の習得

#### 5.11.2. 実装タスク

1. ADOT Collectorのセットアップ（LocalStack）
   - LocalStackでのADOT Collector設定
   - コレクターの基本構成
   - パイプラインの設定
   - エクスポーターの設定
   - レシーバー設定
   - プロセッサー設定
2. OpenTelemetry Go SDKの導入と基本設定
   - トレースプロバイダー設定
   - メトリクスプロバイダー設定
   - ログプロバイダー設定
   - 環境変数での制御
3. X-Ray Exporterの設定
   - X-Ray形式への変換設定
   - サービス名とリソース属性の設定
   - トレース形式変換
   - アノテーションマッピング
   - サンプリング設定
4. クロスプラットフォームコンテキスト伝播の実装
   - W3C Trace Context実装
   - ヘッダー伝播
   - バックエンド間伝播
   - フロントエンド-バックエンド伝播
   - カスタムコンテキスト属性の設計
5. フロントエンドログ収集システムの実装
   - クライアントサイドログ
   - エラーキャプチャ
   - ログ送信バッチ処理
   - プライバシー考慮

#### 5.11.3. フロントエンド学習

- フロントエンドでのログ収集の方法
  - コンソールログの収集
  - カスタムロガーの実装
  - ログレベルの設定
  - バッチ処理と送信
- クライアントサイドエラー監視
  - 未処理例外の捕捉
  - Promiseエラーの監視
  - リソース読み込みエラー
  - API呼び出しエラー
- window.onerrorとunhandledrejectionイベント
  - グローバルエラーハンドラー
  - エラーコンテキストの収集
  - スタックトレース解析
  - エラーグループ化
- カスタムロガーの実装
  - ログレベル定義
  - コンテキスト情報付加
  - ローカルキャッシュ
  - 送信制御

#### 5.11.4. チェックポイント

- [ ] ADOT Collectorが設定され動作している
- [ ] OpenTelemetry SDKが導入されている
- [ ] X-Rayへのデータエクスポートが機能している
- [ ] W3C Trace Contextによるコンテキスト伝播が実装されている
- [ ] フロントエンドでログ収集が実装されている
- [ ] クライアントエラーがキャプチャされている
- [ ] プライバシーに配慮したログ収集になっている

#### 5.11.5. 自己評価基準

- OpenTelemetryのコンセプトとAWS SDK v2との違いを説明できるか
- ADOT Collectorの役割とパイプラインを理解しているか
- コンテキスト伝播の重要性と実装方法を説明できるか
- フロントエンドログの収集方法と留意点を理解しているか
- OpenTelemetryプロジェクトの目標と背景を理解しているか
- 分散システム観測のための統一標準の意義を理解しているか
- プライバシーとセキュリティに配慮したログ収集を実装できているか

### 5.12. 週12: バックエンドのOpenTelemetry移行

#### 5.12.1. 学習目標

- AWS SDK v2からOpenTelemetryへの移行方法の理解
- トレース、メトリクス、ログの統合アプローチの習得
- フロントエンドパフォーマンス計測の概念と方法の理解
- Performance APIの使用方法の習得

#### 5.12.2. 実装タスク

1. X-Ray SDK実装からOpenTelemetryトレースへの移行
   - コード変更
   - 設定移行
   - セグメント/スパンマッピング
   - アノテーション/属性変換
   - Echoミドルウェアの変更
   - データベース操作のトレース更新
   - エラー処理の更新
2. CloudWatch SDKからOpenTelemetryメトリクスへの移行
   - メトリクス定義の変換
   - ディメンション/ラベル変換
   - 集計設定
   - バックフィルと並行実行
3. slogとOpenTelemetryログの統合
   - ログハンドラー実装
   - コンテキスト連携
   - 構造化フォーマット統一
   - 相関ID管理
4. サーバーレス関数のOpenTelemetry対応
   - Lambda関数の変更
   - コンテキスト伝播の実装
   - カスタムメトリクスの移行
   - トレース連携の設定
   - Layer更新
   - 設定の一元管理
   - ローカルテスト
5. フロントエンドパフォーマンス計測の実装
   - Web Vitalsの計測
   - ユーザータイミング
   - リソースタイミング
   - パフォーマンスデータの収集

#### 5.12.3. フロントエンド学習

- Performance API (mark, measure)
  - パフォーマンスマークの設定
  - 区間測定
  - マーク間計測
  - カスタム測定
- Resource Timing API
  - リソース読み込み計測
  - ネットワークタイミング
  - キャッシュ影響
  - クロスオリジン考慮
- ユーザータイミングの計測
  - インタラクションレスポンス
  - アニメーションパフォーマンス
  - レンダリング遅延
  - 体感速度の測定
- パフォーマンスデータの集約方法
  - データ集約
  - パーセンタイル計算
  - 異常値検出
  - 傾向分析

#### 5.12.4. チェックポイント

- [ ] トレース実装がOpenTelemetryに移行されている
- [ ] メトリクス収集がOpenTelemetryに移行されている
- [ ] ログシステムがOpenTelemetryと統合されている
- [ ] サーバーレス関数がOpenTelemetryに対応している
- [ ] フロントエンドでパフォーマンス計測が実装されている
- [ ] データが正しくX-Rayに表示されている
- [ ] 移行前後でデータの整合性が確認されている

#### 5.12.5. 自己評価基準

- AWS SDK v2とOpenTelemetryの違いと移行の利点を説明できるか
- 3本柱（ログ、メトリクス、トレース）の統合方法を理解しているか
- フロントエンドパフォーマンス計測の重要性と方法を説明できるか
- 移行戦略を立案し実行できたか
- 移行プロセスの検証方法を設計できたか
- OpenTelemetryが提供する拡張性を活用できているか
- マルチプラットフォーム対応の観測性システムを設計できたか

### 5.13. 週13: RUMと合成モニタリングの実装

#### 5.13.1. 学習目標

- Real User Monitoring (RUM)の概念と実装方法の理解
- 合成モニタリングの概念と設定方法の習得
- Web Vitalsの理解と最適化方法の習得
- UI/UXパフォーマンスの最適化手法の理解

#### 5.13.2. 実装タスク

1. CloudWatch RUMの設定とNext.jsへの統合
   - RUMクライアントの設定
   - Next.jsとの統合
   - ユーザーセッショントラッキング
   - プライバシー設定
   - パフォーマンスデータの収集
   - エラー収集の設定
2. 実ユーザー体験のモニタリング実装
   - ページロードパフォーマンス
   - ナビゲーショントランジション
   - ユーザーインタラクション計測
   - カスタムイベント計測
   - Web Vitalsの計測
3. CloudWatch Syntheticsの設定
   - カナリアの作成
   - 合成モニタリングの設計
   - 重要ユーザーフローのスクリプト作成
   - スケジュール実行の設定
   - アラート設定
4. 重要ユーザーフローのスクリプト作成
   - 商品閲覧フロー
   - カテゴリーナビゲーション
   - 検索機能
   - エラーパスのテスト
5. UI/UXパフォーマンスの最適化
   - 画像最適化
   - コード分割
   - レンダリング最適化
   - リソース読み込みの最適化・優先度設定
   - アニメーション最適化

#### 5.13.3. フロントエンド学習

- Core Web Vitalsの概念と重要性
  - LCP (Largest Contentful Paint)
  - FID (First Input Delay)
  - CLS (Cumulative Layout Shift)
  - INP (Interaction to Next Paint)
- LCP、FID、CLSの最適化方法
  - リソース読み込み最適化
  - メインスレッド負荷軽減
  - レイアウト安定性
  - アセット最適化
- next/imageの最適化
  - 自動サイズ最適化
  - WebP/AVIF対応
  - 遅延読み込み
  - プレースホルダー
- レイアウト安定性の確保
  - サイズ属性の指定
  - スケルトンUI
  - コンテンツシフト防止
  - アニメーション最適化

#### 5.13.4. チェックポイント

- [ ] CloudWatch RUMがNext.jsアプリに統合されている
- [ ] ユーザーインタラクションが追跡されている
- [ ] 合成モニタリングが設定され実行されている
- [ ] Web Vitalsの値が測定されている
- [ ] パフォーマンス最適化が実施されている
- [ ] 合成テストが重要フローをカバーしている
- [ ] パフォーマンスメトリクスのダッシュボードが作成されている

#### 5.13.5. 自己評価基準

- RUMと合成モニタリングの違いと補完関係を説明できるか
- Web Vitalsの各指標の意味と最適化方法を理解しているか
- ユーザー体験の定量的評価方法を習得したか
- パフォーマンス最適化の効果を測定できるか
- ユーザー体験に影響する要因を包括的に把握できているか
- 合成テストの限界と実ユーザーデータの重要性を理解しているか
- パフォーマンスバジェットの概念と設定方法を理解しているか

### 5.14. 週14: アラートと異常検出・スケルトンUI

#### 5.14.1. 学習目標

- CloudWatch Alertsの設定と活用方法の理解
- 異常検出の概念と実装方法の習得
- スケルトンUIの概念と実装方法の理解
- ローディング最適化手法の習得

#### 5.14.2. 実装タスク

1. CloudWatch Alertの基本設定
   - アラートしきい値設定
   - 複合アラート
   - グループ化設定
   - アクションセットアップ
2. SNS通知の設定
   - SNSトピックの作成
   - サブスクリプション
   - 通知テンプレート
   - エスカレーション
3. 異常検出の実装
   - CloudWatch Anomaly Detectionの設定
   - 動的ベースライン設定
   - 学習期間の設定
   - 特殊イベントフラグ
   - 季節性・トレンド考慮
4. アラートのテストと検証
   - テストアラート発生
   - 異常検出精度の検証
   - エスカレーションフローのテスト
   - 誤検出の分析・最小化
   - チューニング
5. スケルトンローダーコンポーネントの実装
   - 商品カードスケルトン
   - ページスケルトン
   - アニメーション
   - プレースホルダー

#### 5.14.3. フロントエンド学習

- スケルトンUIのデザインパターン
  - パルスアニメーション
  - コンテンツ形状の再現
  - 階層的表示
  - グラデーション効果
- Suspenseとfallbackの活用
  - コード分割対応
  - データフェッチング
  - コンポーネントレベルの制御
  - エラー境界との統合
- プレースホルダーコンテンツの設計
  - LCPの最適化
  - CLS防止
  - アクセシビリティ考慮
  - ブランディング統合
- 知覚パフォーマンスの最適化
  - 先行読み込み
  - インタラクションフィードバック
  - プログレッシブレンダリング
  - 注意制御

#### 5.14.4. チェックポイント

- [ ] アラートが設定され異常時に通知される
- [ ] 動的ベースラインによる異常検出が機能している
- [ ] アラートのテスト手順が確立されている
- [ ] スケルトンローダーがデータ読み込み中に表示される
- [ ] コンテンツのプログレッシブローディングが実装されている
- [ ] アラートがSNSトピックに通知される
- [ ] 異常検出がメトリクスの季節性を考慮している

#### 5.14.5. 自己評価基準

- 効果的なアラート設計の原則を理解しているか
- 異常検出の仕組みと限界を説明できるか
- スケルトンUIの利点とユーザー体験への影響を理解しているか
- 知覚パフォーマンスの最適化手法を実装できたか
- アラート疲れを防ぐ設計ができているか
- アラートのエスカレーションポリシーを設計できているか
- ユーザー体験を重視したローディング戦略を実装できたか

### 5.15. 週15: 顧客向け認証システムの基本実装

#### 5.15.1. 学習目標

- 認証システムの設計と実装方法の理解
- AWS Cognito と自前認証実装の比較と選択方法の理解
- JWT認証基盤の構築方法の習得
- 認証システムのオブザーバビリティ設計の基礎理解
- セキュアな認証フローの実装方法の習得

#### 5.15.2. 実装タスク

1. 認証方式の比較調査（AWS Cognito vs 自前実装）と選択
   - AWS Cognito と自前認証実装の比較分析
   - 認証方式の選定と設計
   - JWT認証の詳細設計
   - セキュリティリスクと対策の検討
   - コスト分析
   - 拡張性評価
2. 選択した方式での認証システムの基本実装
   - ユーザーデータモデル設計
   - パスワードハッシュ処理
   - トークン生成と検証
   - セッション管理
3. ユーザー登録とログイン/ログアウトAPIの実装
   - 入力バリデーション
   - セキュリティ対策
   - エラーハンドリング
   - レート制限
   - パスワードリセットフローの実装
4. ユーザー登録/ログインフォームの実装
   - フォームバリデーション
   - エラー表示
   - UX最適化
   - アクセシビリティ
5. JWT管理と安全な保存の実装
   - トークン発行
   - トークン検証
   - リフレッシュトークン
   - CSRFプロテクション
6. 認証プロセスの基本的なログ記録の実装
   - ログイン試行
   - 失敗理由
   - IP/デバイス情報
   - プライバシー考慮
7. 認証状態のグローバル管理の設計と実装
   - React Context活用
   - 永続化
   - 状態同期
   - タイムアウト処理

#### 5.15.3. チェックポイント

- [ ] 認証方式（Cognito vs 自前実装）の比較分析が完了している
- [ ] ユーザー登録・ログイン機能が動作している
- [ ] JWTによる認証が機能している
- [ ] 認証状態がフロントエンドで適切に管理されている
- [ ] 認証イベントが適切にログ記録されている
- [ ] セキュリティのベストプラクティスが実装されている
- [ ] ユーザーフレンドリーなエラーメッセージが表示される

#### 5.15.4. 自己評価基準

- AWS Cognitoと自前認証実装のトレードオフを説明できるか
- JWT認証の仕組みと安全な実装方法を理解しているか
- 認証システムのセキュリティリスクと対策を説明できるか
- 認証システムの基本的なオブザーバビリティの重要性を説明できるか
- セキュリティとユーザー体験のバランスを考慮できているか
- 認証状態の管理方法とライフサイクルを理解しているか
- ユーザーセキュリティを高めるベストプラクティスを実装できたか

### 5.16. 週16: カート機能と認証連携

#### 5.16.1. 学習目標

- カートシステムの設計と実装方法の理解
- 認証状態に応じたカート管理の実装方法の習得
- 未認証カートから認証カートへの移行機能の設計と実装
- セッション管理とユーザー状態の扱い方の習得
- カート機能のオブザーバビリティ実装手法の理解

#### 5.16.2. 実装タスク

1. カートデータモデルの設計と実装
   - テーブル設計
   - リレーション設定
   - マイグレーション作成
   - ORM設定
   - カートセッション管理の設計
2. 認証連携カートAPIの実装（作成/更新/削除）
   - OpenAPI仕様にカート管理APIを追加
   - 認証検証
   - 認証済みユーザーのカート関連付け
   - エラーハンドリング
   - 集計ロジック
3. 未認証ユーザー用のローカルストレージカート実装
   - データ構造設計
   - CRUD操作
   - 永続化
   - データ検証
4. 認証後のカートデータ統合機能の実装
   - マージ戦略
   - コンフリクト解決
   - データ整合性
   - エラー処理
   - カートの有効期限と自動クリーンアップ
5. カート画面の実装（認証状態に応じた表示切替）
   - カート一覧
   - 数量変更UI
   - 合計計算
   - 認証状態連動
6. カート計算ロジックの実装
   - 数量ベース計算
   - 小計/合計計算
   - 税計算
   - 割引処理
7. カート機能のオブザーバビリティ実装
   - カート操作追跡・監査ログ・イベントの記録
   - バンドル率計測
   - 放棄率計測
   - 遷移率計測

#### 5.16.3. チェックポイント

- [ ] カートデータモデルが適切に設計されている
- [ ] 未認証状態でカート機能が使える
- [ ] 認証状態でカートがユーザーに紐づけられる
- [ ] ログイン時に未認証カートから認証カートへデータ移行できる
- [ ] カート操作のトレース、メトリクス、ログが実装されている
- [ ] カートの計算ロジックが正確に機能している
- [ ] 認証状態の変化にカート表示が適切に対応している

#### 5.16.4. 自己評価基準

- 認証状態によるカート管理の違いを説明できるか
- カートデータの永続化手法を適切に選択できたか
- 認証連携時のデータ統合パターンを理解しているか
- カート機能のオブザーバビリティポイントを特定できるか
- ユーザー体験を考慮したカート設計ができているか
- セッション管理とカートの関係性を理解しているか
- カートのビジネスロジックの分離と再利用ができているか

### 5.17. 週17: ソーシャルログイン連携と注文システム基本実装

#### 5.17.1. 学習目標

- OAuth/OIDC認証の概念と実装方法の理解
- 複数の認証プロバイダーの統合アプローチの習得
- 注文システムの基本設計と実装方法の理解
- 注文データモデルと処理フローの設計スキルの習得
- React Hook Formとバリデーションの実装方法の理解

#### 5.17.2. 実装タスク

1. OAuth/OIDCによるソーシャルログイン基盤の構築
   - フロー設計
   - プロバイダー設定
   - リダイレクト処理
   - トークン検証
2. 主要プロバイダー（Google、Facebook、Githubなど）の連携実装
   - プロバイダー固有設定
   - スコープ定義
   - エラーハンドリング
   - テスト環境
3. ソーシャルプロファイルとローカルユーザーの紐付け
   - プロファイル変換
   - アカウントリンク
   - データマッピング
   - 競合解決
4. 注文データモデルの設計と実装
   - テーブル設計
   - リレーション設定
   - マイグレーション
   - ORM設定
   - 注文状態管理の設計
5. 基本的な注文処理APIの実装
   - OpenAPI仕様に注文処理APIを追加
   - 注文作成
   - 注文確認
   - 注文履歴
   - エラー処理
6. React Hook Formを使った注文フォームの実装
   - フォーム状態管理
   - バリデーション
   - エラー表示
   - ユーザー体験最適化
7. Zodによるバリデーションスキーマの定義と実装
   - スキーマ定義
   - 型推論
   - カスタムバリデーション
   - エラーメッセージ

#### 5.17.3. チェックポイント

- [ ] 少なくとも2つのソーシャルログインプロバイダーが連携している
- [ ] ユーザーアカウントとソーシャルプロファイルの紐付けが機能している
- [ ] 注文データモデルが設計され、データベースに実装されている
- [ ] 基本的な注文処理APIが実装されている
- [ ] React Hook Formによる複雑なフォームバリデーションが実装されている
- [ ] ソーシャルログイン時のエラー処理が適切に実装されている
- [ ] 注文プロセスが認証状態と連携している

#### 5.17.4. 自己評価基準

- OAuth/OIDC認証の流れと仕組みを説明できるか
- 複数認証プロバイダーの統合戦略を適切に実装できたか
- 注文処理の業務フローを適切にモデル化できたか
- React Hook Formを効果的に活用できたか
- バリデーションスキーマを適切に設計・実装できたか
- ユーザー認証情報とプロファイル情報の分離・連携を理解しているか
- セキュリティを考慮したOAuth実装ができているか

### 5.18. 週18: 注文処理と複数ステップフォーム

#### 5.18.1. 学習目標

- 複数ステップフォームの設計と実装方法の理解
- フォームの状態保持と移行の仕組みの習得
- トランザクション管理の実装方法の理解
- 注文確認と処理のワークフローデザインの習得
- ユーザー体験を考慮したフォーム設計の理解

#### 5.18.2. 実装タスク

1. 複数ステップのチェックアウトフォーム実装
   - ステップ定義
   - ステップ間のナビゲーション実装
   - ステート管理
   - バリデーション設計
   - 進行状態保存
2. ステップ間のナビゲーションとデータ保持の実装
   - ステップ間の遷移制御
   - 部分的データ保存
   - 戻る機能
   - バリデーションチェック
3. フォームコンテキストの実装
   - グローバル状態管理
   - フォーム値の永続化
   - ステップ間のデータ共有
   - コンテキストプロバイダー
4. プログレスインジケーターの実装
   - 進捗可視化
   - アクティブステップ表示
   - 完了ステップマーキング
   - アクセシビリティ対応
5. 注文確認プロセスの実装
   - 注文サマリー表示
   - 最終確認UI
   - 確定アクション
   - 完了通知
6. トランザクション処理の実装
   - トランザクション開始/コミット
   - 在庫確認と予約
   - エラー処理とロールバック
   - 注文ID生成
7. 注文完了と確認画面の実装
   - 注文確認UI
   - 注文詳細表示
   - 次のステップ案内
   - 購入履歴連携
8. 注文履歴の実装
   - 注文履歴ページの設計と実装
   - 注文詳細表示
   - 注文ステータストラッキング
   - 注文のフィルタリングと検索

#### 5.18.3. フロントエンド学習

- ステートマシンを使ったフォーム管理
  - 状態遷移の定義
  - 条件付き遷移
  - 状態保持
  - ユーザーフロー制御
- コンテキストを使った状態共有
  - Contextの作成
  - カスタムフック設計
  - 状態の分離と集約
  - パフォーマンス最適化
- 多段階フォームのUX設計
  - 視覚的フィードバック
  - 入力保存ポイント
  - エラー表示タイミング
  - 進捗感の演出
- トランザクションUIパターン
  - ロック機構
  - タイムアウト処理
  - 確定/キャンセルフロー
  - アンドゥ/リドゥ機能

#### 5.18.4. チェックポイント

- [ ] 複数ステップフォームが実装され、ユーザーの入力を保持できる
- [ ] ステップ間のナビゲーションがスムーズに機能する
- [ ] プログレスインジケーターが実装されている
- [ ] 注文処理がトランザクション管理されている
- [ ] 注文完了後に適切な確認情報が表示される
- [ ] バリデーションが適切なタイミングで実行される
- [ ] フォームコンテキストがステップ間でデータを共有できる

#### 5.18.5. 自己評価基準

- ステートマシンを使ったステップ管理を実装できたか
- ウィザードパターンを適切に適用できたか
- フォームデータの一時保存と最終送信を適切に設計できたか
- トランザクション管理を適切に実装できたか
- ユーザー体験を考慮したフォーム設計ができたか
- 柔軟で拡張可能なフォームアーキテクチャを設計できたか
- エラー処理と回復メカニズムを組み込めたか

### 5.19. 週19: 注文関連イベント処理とオブザーバビリティ強化

#### 5.19.1. 学習目標

- イベント駆動型アーキテクチャの原則と実装方法の理解
- 非同期処理の設計と実装方法の習得
- エンドツーエンドトレースの設計と実装方法の理解
- 認証・注文フローの包括的なオブザーバビリティ実装の習得
- 高度なオブザーバビリティダッシュボードの設計と実装

#### 5.19.2. 実装タスク

1. イベント駆動型アーキテクチャの設計と実装
   - 注文イベントの定義
   - イベントバス設計
   - プロデューサー実装
   - コンシューマー実装
   - EventBridgeの設定
   - SNSトピックの設定
   - SQSキューの設定
2. 注文確認メール送信機能の実装
   - テンプレート設計
   - メール送信サービス
   - エラー処理
   - 再送メカニズム
3. 在庫更新処理の実装
   - 在庫引当
   - 在庫同期
   - 在庫不足対応
   - 整合性確保
4. カート→認証→注文→イベント処理のトレース連携実装
   - トレースコンテキスト伝播
   - クロスサービストレース
   - ユーザージャーニー可視化
   - パフォーマンス分析
5. 認証・注文プロセスのダッシュボード作成
   - 変換率可視化
   - ファネル分析
   - エラー率モニター
   - パフォーマンス指標
6. 認証セキュリティモニタリングの実装
   - 異常検出
   - 地理的アクセス分析
   - 攻撃パターン検知
   - リスクスコアリング
7. ログ検索クエリとアラートの作成
   - CloudWatch Logs Insights
   - 高度なクエリ
   - アラート設定
   - レポート自動化
8. 注文処理のオブザーバビリティ実装
   - 注文フローのOTELトレース設定
   - 注文関連メトリクスの設計と実装
   - 注文プロセスの監査ログ
   - トランザクションの監視
9. イベント処理のオブザーバビリティ
   - イベント処理のOTELトレース設定
   - イベント処理メトリクスの設計と実装
   - イベント処理ログの強化
   - 非同期処理の監視
10. エラー処理とリトライメカニズム
    - デッドレターキューの設定
    - リトライ戦略の実装
    - エラーハンドリングの強化
    - 障害通知の設定

#### 5.19.3. チェックポイント

- [ ] 注文イベントが発行され、イベントハンドラーで処理される
- [ ] 注文確認メールが送信される
- [ ] 在庫が注文に応じて更新される
- [ ] エンドツーエンドトレースが完全に実装されている
- [ ] 認証・注文プロセスのダッシュボードが作成されている
- [ ] 認証セキュリティモニタリングが機能している
- [ ] 異常な認証パターンを検出するアラートが設定されている

#### 5.19.4. 自己評価基準

- イベント駆動型アーキテクチャの利点と実装方法を理解しているか
- 非同期処理のパターンを適切に選択できるか
- エンドツーエンドトレースの実装方法を理解しているか
- 認証セキュリティの監視ポイントを特定できるか
- 効果的なダッシュボード設計ができたか
- 複雑なシステムを包括的に監視する能力を身につけたか
- ビジネスメトリクスと技術メトリクスの関連付けができているか

### 5.20. 週20: 管理者認証と権限管理の実装

#### 5.20.1. 学習目標

- 管理者向け認証システムの設計と実装方法の理解
- ロールベースのアクセス制御（RBAC）の概念と実装の習得
- 多要素認証（MFA）の実装方法の理解
- 監査ログシステムの設計と実装方法の理解
- 特権アクセス管理の原則と実装方法の習得

#### 5.20.2. 実装タスク

1. 管理者認証システムの詳細設計と実装
   - モック認証からの本格実装への移行
   - 認証プロセス設計
   - 管理者ユーザーモデル
   - セッション管理
   - セキュリティ対策
2. ロールと権限のデータモデル設計
   - ロールテーブル
   - 権限テーブル
   - ユーザーロール関連
   - 権限階層
3. 権限チェックミドルウェアの実装
   - リクエスト検証
   - 権限検証ロジック
   - エラー処理
   - キャッシュ戦略
4. 多要素認証（MFA）の実装
   - TOTP実装
   - リカバリーコード
   - デバイス管理
   - セットアップフロー
5. 管理者ログイン画面の強化
   - MFA UI
   - セキュリティ強化UI
   - エラーハンドリング
   - ユーザビリティ
   - 管理者ログイン画面の強化
   - MFA設定・検証フロー
   - 権限管理インターフェース
   - ユーザーとロールの管理画面
6. セッション管理と有効期限設定
   - セッションストア
   - タイムアウト処理
   - 同時セッション制御
   - 強制ログアウト機能
7. 管理者操作の監査ログシステムの実装
   - 操作ログ記録
   - 操作者情報
   - 変更履歴
   - 検索・フィルタリング機能
8. 監査ログシステムの実装
   - 管理者操作の詳細記録
   - 権限変更の監査証跡
   - ログフォーマットと保存ポリシー
   - ログ検索・分析インターフェース
9. 管理者認証のオブザーバビリティ
   - 管理者認証イベントのモニタリング
   - アクセス試行パターンの分析
   - 権限変更の追跡と可視化
   - セキュリティアラートの設定

#### 5.20.3. チェックポイント

- [ ] 管理者認証システムが実装されている
- [ ] ロールベースのアクセス制御が機能している
- [ ] 多要素認証が実装されている
- [ ] 権限チェックミドルウェアが各APIエンドポイントで機能している
- [ ] 管理者操作の監査ログが記録されている
- [ ] セッション管理と有効期限が適切に設定されている
- [ ] 管理者ログイン画面がMFAに対応している

#### 5.20.4. 自己評価基準

- ロールベースのアクセス制御の設計原則を理解しているか
- 多要素認証の実装方法と安全性を理解しているか
- 監査ログシステムの設計と実装ができたか
- 特権アクセス管理のベストプラクティスを適用できたか
- 管理者認証のオブザーバビリティポイントを適切に設計できたか
- セキュリティとユーザビリティのバランスを取れているか
- 権限モデルのスケーラビリティと管理性を考慮できているか

### 5.21. 週21: 商品管理機能の拡張と権限連携

#### 5.21.1. 学習目標

- 商品管理システムの拡張設計と実装方法の理解
- データテーブルの設計と実装方法の習得
- 商品管理へのRBAC統合方法の習得
- 商品データ品質モニタリングの実装方法の理解
- 商品操作の監査と変更履歴管理の実装方法の習得

#### 5.21.2. 実装タスク

1. 商品管理APIの拡張（一括操作、詳細検索）
   - バルク操作API
   - 高度な検索条件
   - フィルタリング機能
   - ソート機能
   - 商品データエクスポート/インポートAPI
   - バージョン管理APIの追加
2. 商品カテゴリーベースの権限管理実装
   - カテゴリー権限モデル
   - 権限チェックロジック
   - UI制御連携
   - 階層的権限
   - 商品管理操作への権限チェック統合
   - ロールベースのUI表示制御
   - 商品データアクセス制御
3. 高度なデータテーブルコンポーネントの実装
   - カスタムデータグリッド
   - カラム設定
   - 行アクション
   - インラインエディット
4. 商品変更履歴の記録と表示機能
   - 変更検出
   - 差分記録
   - 履歴表示UI
   - 変更者追跡
5. 商品データ品質モニタリングの実装
   - データ検証ルール
   - 品質スコア計算
   - 問題検出
   - 改善提案
   - 画像品質チェック
   - SEO最適化チェック
   - データ完全性スコアリング
6. 権限に基づいたUI表示制御の実装
   - 条件付きレンダリング
   - 機能制限
   - エラーメッセージ
   - UX最適化
7. 商品管理操作の監査ログ強化
   - 詳細操作記録
   - コンテキスト情報
   - 関連操作グループ化
   - セキュリティ分析
8. 商品管理画面の強化
   - 高度な商品検索UI
   - 一括編集機能
   - ドラッグ&ドロップでの並べ替え
   - 商品属性の管理
   - 権限に基づいたUI制御
9. 商品管理のオブザーバビリティ
   - 管理操作のOTELトレース設定
   - 管理アクションのメトリクス実装
   - 管理操作の監査ログ
   - 変更履歴の追跡

#### 5.21.3. チェックポイント

- [ ] 商品管理APIが拡張され、権限チェックが統合されている
- [ ] カテゴリーベースの権限管理が機能している
- [ ] データテーブルがソート、フィルタリング、ページネーションに対応している
- [ ] 商品変更履歴が記録され、表示できる
- [ ] 商品データ品質がモニタリングされている
- [ ] UIが権限に基づいて適切に制御されている
- [ ] 商品管理操作の詳細な監査ログが記録されている

#### 5.21.4. 自己評価基準

- 商品管理システムの高度な機能を設計・実装できたか
- RBACと商品管理を効果的に統合できたか
- データテーブルの高度な機能を実装できたか
- 変更履歴管理の設計と実装ができたか
- 権限ベースのUI制御をどの程度うまく実装できたか
- 商品データ品質の監視と改善の自動化ができているか
- 監査ログのセキュリティ分析への活用方法を理解しているか

### 5.22. 週22: 在庫管理システムと権限連携

#### 5.22.1. 学習目標

- 在庫管理システムの設計と実装方法の理解
- 在庫レベルモニタリングと通知の習得
- 在庫管理へのRBAC統合方法の習得
- モーダル、ダイアログ、ポップオーバーの実装方法の理解
- アクセシビリティを考慮したUIの実装方法の習得

#### 5.22.2. 実装タスク

1. 在庫管理APIの実装（更新、履歴、予測）
   - 在庫レベル管理
   - 入出庫記録
   - 在庫履歴
   - 予測アルゴリズム
   - 在庫アラートAPIの実装
2. 在庫操作の権限管理実装
   - 監査要件に基づく権限設計
   - 役割ごとの在庫管理権限設定
   - 在庫確認権限
   - 在庫調整権限
   - 監査要件対応
   - 権限ベースの在庫データアクセス制御
3. 在庫管理画面の実装（権限統合）
   - 在庫一覧表示
   - 在庫レベル可視化
   - 入出庫操作UI
   - 在庫調整UI
   - 権限に基づいたUI表示制御
4. 在庫レベルの可視化と監視の実装
   - グラフ表示
   - トレンド分析
   - しきい値監視
   - アラート設定
5. 在庫アラートの設定
   - 在庫不足アラート
   - 過剰在庫アラート
   - 自動アクション
   - 在庫変動異常検出
   - アラート通知の最適化
6. 商品編集モーダルの実装（アクセシビリティ対応）
   - WAI-ARIA対応
   - キーボード操作
   - スクリーンリーダー対応
   - フォーカス管理
7. 在庫操作の監査ログ実装
   - 操作記録
   - 在庫変動追跡
   - 調整理由記録
   - 承認フロー
8. 在庫管理のオブザーバビリティ
   - 在庫操作のOTELトレース設定
   - 在庫レベルのメトリクス実装
   - 在庫変動の監査ログ
   - 在庫予測と実績の比較

#### 5.22.3. チェックポイント

- [ ] 在庫管理APIが実装され、権限チェックが統合されている
- [ ] 在庫操作の権限管理が機能している
- [ ] 在庫管理画面が権限に応じて適切に表示される
- [ ] 在庫レベルが視覚的に表示され、監視されている
- [ ] 在庫アラートが設定されている
- [ ] モーダルとポップオーバーがアクセシビリティに配慮して実装されている
- [ ] 在庫操作の詳細な監査ログが記録されている

#### 5.22.4. 自己評価基準

- 在庫管理システムの設計と実装ができたか
- 在庫管理へのRBAC統合がうまくできたか
- 在庫モニタリングと予測機能の実装ができたか
- アクセシビリティの原則を理解し、UIに適用できたか
- 在庫管理のオブザーバビリティポイントを適切に設計できたか
- 在庫管理と商品管理の統合ができているか
- 在庫データの分析と意思決定支援の仕組みを実装できたか

### 5.23. 週23: 管理機能の包括的オブザーバビリティ

#### 5.23.1. 学習目標

- 管理機能に関する包括的なオブザーバビリティの設計と実装
- 管理操作の詳細分析手法の習得
- セキュリティ監視の強化方法の理解
- 統合ダッシュボードの設計と実装方法の習得
- オブザーバビリティデータの統合分析手法の理解

#### 5.23.2. 実装タスク

1. 管理ダッシュボードの統合
   - ビジネスインテリジェンス
   - 運用モニタリング
   - セキュリティ監視
   - パフォーマンス分析
   - 品質ダッシュボード
   - 予測ダッシュボード
2. ユーザー別・権限別の操作分析機能実装
   - ユーザー活動分析
   - 権限使用パターン
   - 異常検出
   - 効率性分析
3. 管理操作の時間帯別・影響範囲分析
   - 時系列分析
   - 影響範囲評価
   - リスク分析
   - 最適時間帯提案
4. セキュリティ監視の強化（権限変更の監視、特権アクセスの監視）
   - 権限変更追跡
   - 特権操作モニタリング
   - セキュリティイベント相関
   - インシデント検出
   - 異常な管理操作パターンの検出
5. 異常な管理操作パターンの検出機能
   - 行動ベースライン
   - 異常スコアリング
   - アラート生成
   - インシデント対応連携
6. クロスサービスの依存関係マップ作成
   - サービス依存性可視化
   - 影響範囲分析
   - ボトルネック特定
   - 障害伝播予測
7. 管理オペレーションのSLI/SLO設定
   - サービスレベル指標
   - 目標設定
   - モニタリング
   - 改善サイクル
8. 包括的モニタリングの実装
   - データフローの可視化
   - システム依存関係マップ
   - リソース使用量の予測
   - 異常検出の精度向上
9. オブザーバビリティデータの統合
   - ログ、メトリクス、トレースの完全統合
   - コンテキスト間の相関分析
   - 根本原因分析の自動化
   - インシデント予測と防止

#### 5.23.3. チェックポイント

- [ ] 統合管理ダッシュボードが実装されている
- [ ] 管理操作の詳細分析が可能になっている
- [ ] セキュリティ監視が強化されている
- [ ] 異常な管理操作パターンが検出される
- [ ] クロスサービスの依存関係マップが作成されている
- [ ] 管理オペレーションのSLI/SLOが設定されている
- [ ] 包括的なオブザーバビリティシステムが機能している

#### 5.23.4. 自己評価基準

- 管理機能の包括的なオブザーバビリティを設計・実装できたか
- セキュリティ監視の強化ポイントを特定し実装できたか
- 統合ダッシュボードの設計と実装ができたか
- オブザーバビリティデータの相関分析機能を実装できたか
- 管理機能のパフォーマンスと品質を測定できるメトリクスを設計できたか
- セキュリティとビジネス指標の統合ができているか
- データ駆動の意思決定を支援する仕組みを構築できたか

### 5.24. 週24: AWS環境への本番デプロイ準備

#### 5.24.1. 学習目標

- Terraformによる本番環境インフラ定義の理解
- CI/CDパイプラインの設計と実装方法の習得
- 本番環境のオブザーバビリティ設定の理解
- Next.jsのビルドパフォーマンス最適化方法の理解
- 本番環境のセキュリティ設定と最適化の習得

#### 5.24.2. 実装タスク

1. Terraformによる本番環境インフラ定義
   - VPC設計
   - サブネット設計
   - セキュリティグループ
   - IAMロール設定
   - ECS/Fargate、RDS、Lambdaリソースの定義
   - CloudWatch、X-Ray、SNSリソースの設定
2. GitHub Actionsワークフローの設定
   - CI設定
   - テスト自動化
   - ビルドプロセス
   - デプロイフロー
   - 環境分離
3. 本番環境のセキュリティ設定
   - WAF設定
   - IAM権限最小化
   - セキュリティグループ
   - KMS暗号化
   - セキュリティスキャン
4. 本番環境のオブザーバビリティ設定
   - ログ集約
   - メトリクス設定
   - トレース設定・トレースサンプリングの最適化
   - アラート構成
   - ダッシュボード設定
   - コスト効率の最適化
5. パフォーマンステストとベンチマーク
   - 負荷テスト
   - スケーリングテスト
   - パフォーマンス計測
   - ボトルネック特定
   - リソース割り当ての最適化
6. Next.jsアプリのビルド最適化
   - バンドル分析
   - コード分割
   - 静的生成最適化
   - キャッシュ戦略
   - イメージ最適化
7. 環境変数と秘密情報の管理
   - Secrets Manager
   - Parameter Store
   - 環境変数管理
   - ローテーション
   - アクセス制御

#### 5.24.3. チェックポイント

- [ ] Terraformでインフラが定義されている
- [ ] CI/CDパイプラインが設定されている
- [ ] 本番環境のセキュリティが適切に設定されている
- [ ] 本番環境のオブザーバビリティが設定されている
- [ ] パフォーマンステストが実行されている
- [ ] Next.jsのビルドが最適化されている
- [ ] 環境変数と秘密情報が適切に管理されている

#### 5.24.4. 自己評価基準

- Terraformによるインフラのコード化を理解しているか
- CI/CDパイプラインの設計原則を理解しているか
- 本番環境のセキュリティ設定ベストプラクティスを適用できたか
- 本番環境と開発環境の設定の違いを理解しているか
- Next.jsのビルド最適化手法を適用できたか
- パフォーマンステストの設計と実行ができたか
- 秘密情報管理のベストプラクティスを実装できたか

### 5.25. 週25: 耐障害性とカオスエンジニアリング

#### 5.25.1. 学習目標

- AWS Fault Injection Serviceの概念と使用方法の理解
- カオスエンジニアリングの原則と実践方法の習得
- 耐障害性の評価と強化手法の理解
- 障害復旧手順と自動化の設計と実装方法の習得
- 本番環境へのDeployment戦略の理解

#### 5.25.2. 実装タスク

1. AWS Fault Injection Serviceの設定
   - 実験テンプレート
   - 安全メカニズム
   - モニタリング設定
   - ロールバック手順
2. 障害シナリオの設計と実装
   - ネットワーク障害
   - コンピューティング障害
   - データベース障害
   - 依存サービス障害
3. カオスエンジニアリング実験の実施
   - 制御された障害注入
   - 仮説検証
   - システム応答分析
   - 改善点特定
4. 耐障害性の評価と強化
   - 復旧時間測定
   - 障害範囲分析
   - 耐障害性スコア
   - 設計改善
5. 障害復旧手順の策定と文書化
   - 復旧手順書
   - チェックリスト
   - 役割分担
   - エスカレーションフロー
6. ブルー/グリーンデプロイメントの設定
   - デプロイ戦略
   - トラフィック切替
   - ロールバック
   - 検証プロセス
7. 本番環境への最終デプロイ
   - デプロイ計画
   - リスク評価
   - 段階的デプロイ
   - モニタリング強化

#### 5.25.3. チェックポイント

- [ ] AWS Fault Injection Serviceが設定されている
- [ ] 複数の障害シナリオがテストされている
- [ ] カオスエンジニアリング実験が実施されている
- [ ] 耐障害性が評価され改善されている
- [ ] 障害復旧手順が文書化されている
- [ ] ブルー/グリーンデプロイメントが設定されている
- [ ] 本番環境への最終デプロイが完了している

#### 5.25.4. 自己評価基準

- AWS Fault Injection Serviceの使用方法を理解しているか
- カオスエンジニアリングの原則と利点を理解しているか
- 耐障害性の評価方法を習得したか
- 障害復旧手順を適切に設計・文書化できたか
- 安全なデプロイメント戦略を理解し実装できたか
- 障害シナリオの設計と実行ができるか
- システムの弱点を特定し、改善する方法を習得したか

## 6. 学習環境でのコスト管理

### 6.1. フェーズ別コスト概算

学習環境での各フェーズのおおよそのコスト概算です。すべてのサービスを同時に使用するのではなく、限られた時間だけ稼働させることでコストを抑制できます。

| フェーズ                              | 主要コスト要素                 | 対策を講じない場合の月額コスト | 学習最適化後の月額コスト |
| ------------------------------------- | ------------------------------ | ------------------------------ | ------------------------ |
| **フェーズ1: 基盤構築と商品閲覧機能** | RDS, Fargate                   | $50-70                         | $10-15                   |
| **フェーズ2: 統合オブザーバビリティ** | CloudWatch, X-Ray, Lambda      | $80-100                        | $15-20                   |
| **フェーズ3: OpenTelemetry**          | ADOT Collector, CloudWatch RUM | $100-120                       | $20-25                   |
| **フェーズ4: 注文機能**               | RDS, Fargate, SNS/SQS          | $90-110                        | $18-23                   |
| **フェーズ5: 管理機能**               | RDS, Fargate, CloudWatch       | $70-90                         | $15-18                   |
| **フェーズ6: 本番環境**               | すべてのサービス + FIS         | $120-150                       | $25-30                   |

### 6.2. コスト最適化戦略

学習環境でのコストを効率的に管理するための戦略：

1. **時間制限による稼働**
   - 学習セッション時のみリソースを起動
   - 夜間・週末の自動停止
   - スケジュールベースの起動/停止

2. **リソースのサイズ最適化**
   - 最小サイズのインスタンス選択
   - メモリ割り当ての最適化
   - ストレージサイズの最小化

3. **サンプリングとフィルタリング**
   - トレースのサンプリング率調整
   - ログフィルタリングの実装
   - メトリクス収集の選択的実行

4. **LocalStackの活用**
   - 可能な限りLocalStackでのエミュレーション
   - 実AWSサービスは検証時のみ使用
   - ハイブリッドアプローチの採用

### 6.3. 週あたりの学習時間を考慮した配分

週あたり20時間の学習を想定した場合のコスト最適化例：

| 使用パターン                      | 週あたりの稼働時間 | 月間コストへの影響                   |
| --------------------------------- | ------------------ | ------------------------------------ |
| **平日限定（4時間×5日）**         | 20時間/週          | 約12%の稼働（月間730時間中の86時間） |
| **週末集中（10時間×2日）**        | 20時間/週          | 約11%の稼働（月間730時間中の80時間） |
| **分散学習（3時間×週6日+2時間）** | 20時間/週          | 約11%の稼働（月間730時間中の80時間） |

これにより、フルタイム稼働に比べて約85-90%のコスト削減が可能です。

## 7. 自己学習のためのアドバイス

1. **一度に完璧を目指さない**: 各週のタスクは挑戦的です。理解しながら進み、必要に応じて次週に調整してください。

2. **実践的アプローチ**: 理論だけでなく、必ず手を動かしてコードを書きましょう。

3. **問題解決力を鍛える**: エラーや課題に直面したら、まずは自分で解決策を探し、その過程を記録してください。

4. **コミュニティリソースの活用**: GitHub、Stack Overflow、AWS公式ドキュメントを活用してください。

5. **定期的な振り返り**: 週の終わりに学んだことを振り返り、ブログや記事として整理すると理解が深まります。

6. **小さな成功を祝う**: 小さな進歩も成果として認め、モチベーションを維持しましょう。

7. **優先順位をつける**: すべてを完璧に実装するのではなく、学習目標に沿って優先順位をつけましょう。

8. **ドキュメント作成を習慣化**: 実装した内容や学んだことを文書化する習慣をつけましょう。

9. **セキュリティを常に意識**: 開発の最初からセキュリティを考慮したアプローチを取りましょう。

10. **同じ課題を異なる方法で解決**: 同じ問題を別のアプローチで解決してみると、理解が深まります。

この23週間の旅が、あなたのエンジニアとしてのスキルと理解を次のレベルに引き上げる助けとなることを願っています。

## 8. 参考リソース

### 8.1. 公式ドキュメント

- [AWS公式ドキュメント](https://docs.aws.amazon.com/)
- [Go言語公式ドキュメント](https://golang.org/doc/)
- [Next.js公式ドキュメント](https://nextjs.org/docs)
- [OpenTelemetry公式ドキュメント](https://opentelemetry.io/docs/)
- [AWS SDK for Go v2](https://aws.github.io/aws-sdk-go-v2/docs/)
- [Echo Framework Documentation](https://echo.labstack.com/)
- [Terraform AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)

### 8.2. チュートリアルとコース

- [AWS Well-Architected Labs](https://www.wellarchitectedlabs.com/)
- [AWS Observability Workshop](https://observability.workshop.aws/)
- [LocalStack公式チュートリアル](https://docs.localstack.cloud/tutorials/)
- [Go Web Development Tutorials](https://gowebexamples.com/)
- [Next.js Learn](https://nextjs.org/learn)
- [React Hooks Documentation](https://reactjs.org/docs/hooks-intro.html)
- [Learn Terraform - AWS](https://learn.hashicorp.com/collections/terraform/aws-get-started)

### 8.3. ブログと記事

- [AWSブログ: Observabilityカテゴリ](https://aws.amazon.com/blogs/architecture/category/management-tools/observability/)
- [OpenTelemetryブログ](https://opentelemetry.io/blog/)
- [AWS DevOps Blog](https://aws.amazon.com/blogs/devops/)
- [Next.js Blog](https://nextjs.org/blog)
- [Go Blog](https://blog.golang.org/)
- [TailwindCSS Blog](https://blog.tailwindcss.com/)
- [Terraform Blog](https://www.hashicorp.com/blog/products/terraform)

### 8.4. コミュニティとフォーラム

- [AWS re:Post](https://repost.aws/)
- [OpenTelemetry Slack](https://cloud-native.slack.com/archives/C01NPAXACKT)
- [Gopher Slack](https://gophers.slack.com/)
- [Next.js Discord](https://discord.com/invite/Next-js)
- [AWS Community](https://aws.amazon.com/developer/community/)
- [Terraform Community](https://www.terraform.io/community)
- [Stack Overflow - AWS Tags](https://stackoverflow.com/questions/tagged/amazon-web-services)
- [Stack Overflow - OpenTelemetry Tags](https://stackoverflow.com/questions/tagged/opentelemetry)
